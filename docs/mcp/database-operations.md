# Database Operations via MCP

This guide covers how to use the Prisma MCP server for database operations in the SPYMEO project.

## Overview

The Prisma MCP server provides AI-assisted database operations, including:

- Schema design and modifications
- Migration creation and management
- Query generation and optimization
- Database seeding
- Schema introspection

## Configuration

The Prisma MCP server is configured in `.mcp/servers/database.json` and `.mcp/config.json`.

### Environment Variables

```bash
DATABASE_URL="postgresql://user:password@localhost:5432/spymeo"
```

### MCP Server Command

```bash
npx prisma mcp
```

## Available Tools

### 1. Schema Operations

#### Read Schema
```
Ask Claude: "Show me the current database schema"
Ask Claude: "What are all the models in the database?"
Ask Claude: "Show me the User model definition"
```

**Tool**: `prisma:schema:read`

#### Validate Schema
```
Ask Claude: "Validate the Prisma schema for errors"
Ask Claude: "Check if the schema is valid"
```

**Tool**: `prisma:schema:validate`

#### Generate Client
```
Ask Claude: "Generate the Prisma Client"
Ask Claude: "Regenerate Prisma Client after schema changes"
```

**Tool**: `prisma:model:generate`

### 2. Migration Operations

#### Create Migration
```
Ask Claude: "Create a migration to add an 'avatar' field to the User model"
Ask Claude: "Add a 'bio' field (Text, optional) to Practitioner"
Ask Claude: "Create a new Appointment model with relations to User and Practitioner"
```

**Tool**: `prisma:migration:create`

**Parameters**:
- `name` (required): Migration name
- `createOnly` (optional): Create without applying

**Example**:
```
Developer: "Add a phone number field to users"

Claude Response:
I'll create a migration to add a phone field to the User model.

1. First, I'll read the current schema to understand the User model
2. Then create a migration with the new field
3. Apply the migration to update the database

[Claude executes]:
- prisma:schema:read
- prisma:migration:create with name "add_user_phone"
- prisma:migration:apply
```

#### Apply Migrations
```
Ask Claude: "Apply pending database migrations"
Ask Claude: "Run migrations without seeding"
```

**Tool**: `prisma:migration:apply`

**Parameters**:
- `skipSeed` (optional): Skip database seeding after migration

#### Migration Status
```
Ask Claude: "What migrations are pending?"
Ask Claude: "Show migration history"
Ask Claude: "Which migrations have been applied?"
```

**Tool**: `prisma:migration:status`

### 3. Query Operations

#### Generate Queries
```
Ask Claude: "Generate a query to find all practitioners in Paris"
Ask Claude: "Create a query to get a user with their appointments"
Ask Claude: "Write a query to update practitioner availability"
```

**Tool**: `prisma:query:execute`

**Parameters**:
- `model` (required): Prisma model name
- `operation` (required): findMany, findUnique, create, update, delete, upsert
- `data` (optional): Query parameters

**Example**:
```typescript
// Generated by Claude via MCP
const practitioners = await prisma.practitioner.findMany({
  where: {
    city: 'Paris',
    specialty: 'Yoga',
    acceptsPass: true
  },
  include: {
    user: {
      select: {
        name: true,
        email: true,
        avatar: true
      }
    },
    reviews: {
      orderBy: {
        createdAt: 'desc'
      },
      take: 5
    }
  },
  orderBy: {
    rating: 'desc'
  }
});
```

#### Optimize Queries
```
Ask Claude: "Optimize this query for better performance"
Ask Claude: "This query is slow, can you improve it?"
Ask Claude: "Add proper indexes for the User.email field"
```

**Prompt**: `optimize-query`

### 4. Database Seeding

#### Run Seed Script
```
Ask Claude: "Seed the database with initial data"
Ask Claude: "Run the database seed script"
```

**Tool**: `prisma:db:seed`

**Parameters**:
- `file` (optional): Seed file path (default: `./prisma/seed.ts`)

### 5. Prisma Studio

#### Launch Studio
```
Ask Claude: "Open Prisma Studio"
Ask Claude: "Launch the database management UI"
```

**Tool**: `prisma:studio:launch`

**Parameters**:
- `port` (optional): Port number (default: 5555)

## Common Workflows

### 1. Adding a New Field

**Scenario**: Add an `avatar` field to the User model

```
Developer: "Add an avatar URL field to users"

Claude Workflow:
1. Read current User model schema
2. Identify appropriate field type (String, optional)
3. Create migration: "add_user_avatar"
4. Apply migration
5. Generate updated Prisma Client
6. Confirm completion

Result:
- Migration file created in prisma/migrations/
- Database updated with new column
- Prisma Client regenerated
- TypeScript types updated
```

### 2. Creating a New Model

**Scenario**: Create an Invoice model

```
Developer: "Create an Invoice model with number, amount, dueDate, and relation to User"

Claude Workflow:
1. Design schema based on requirements:
   - id: String @id @default(cuid())
   - number: String @unique
   - amount: Float
   - dueDate: DateTime
   - status: InvoiceStatus (enum)
   - userId: String
   - user: User @relation
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt

2. Create migration: "create_invoice_model"
3. Apply migration
4. Generate Prisma Client
5. Suggest API endpoints and TypeScript types

Result:
- New Invoice table in database
- Relations configured
- Types available in code
```

### 3. Modifying Relations

**Scenario**: Add appointments relation to Practitioner

```
Developer: "Add a one-to-many relation from Practitioner to Appointment"

Claude Workflow:
1. Read both model schemas
2. Identify relation fields needed
3. Create migration: "add_practitioner_appointments_relation"
4. Update both models:
   - Practitioner: appointments Appointment[]
   - Appointment: practitionerId String, practitioner Practitioner @relation
5. Apply migration
6. Regenerate client

Result:
- Foreign key created
- Relation accessible in queries
- TypeScript types include relation
```

### 4. Query Optimization

**Scenario**: Optimize slow practitioner search

```
Developer: "This query is slow, optimize it:"
```typescript
const practitioners = await prisma.practitioner.findMany({
  include: {
    user: true,
    appointments: true,
    reviews: true
  }
});
```

Claude Analysis:
1. Issues identified:
   - Loading all appointments (could be thousands)
   - No pagination
   - No selective field inclusion
   - Missing indexes

2. Optimized query:
```typescript
const practitioners = await prisma.practitioner.findMany({
  select: {
    id: true,
    specialty: true,
    rating: true,
    user: {
      select: {
        name: true,
        avatar: true
      }
    },
    _count: {
      select: {
        appointments: true,
        reviews: true
      }
    }
  },
  take: 20,
  skip: page * 20
});
```

3. Recommended indexes:
```prisma
model Practitioner {
  @@index([specialty])
  @@index([rating])
  @@index([city])
}
```

Result:
- Query time reduced from 2s to 50ms
- Reduced data transfer
- Added pagination
```

### 5. Data Migration

**Scenario**: Migrate data when changing field types

```
Developer: "Change User.role from String to enum UserRole"

Claude Workflow:
1. Create enum definition
2. Create migration with data transformation:
```sql
-- Create enum
CREATE TYPE "UserRole" AS ENUM ('USER', 'PRACTITIONER', 'MERCHANT', 'ADMIN');

-- Migrate data
UPDATE "User" SET "role" = CASE
  WHEN "role" = 'user' THEN 'USER'::text
  WHEN "role" = 'practitioner' THEN 'PRACTITIONER'::text
  WHEN "role" = 'merchant' THEN 'MERCHANT'::text
  WHEN "role" = 'admin' THEN 'ADMIN'::text
  ELSE 'USER'::text
END;

-- Change column type
ALTER TABLE "User" ALTER COLUMN "role" TYPE "UserRole" USING "role"::"UserRole";
```

3. Apply migration
4. Update TypeScript enums

Result:
- Type safety improved
- Data preserved
- Existing records migrated correctly
```

## Schema Design Best Practices

### 1. Naming Conventions

```prisma
// Models: PascalCase, singular
model User { }
model Practitioner { }

// Fields: camelCase
model User {
  firstName String
  lastName String
  emailVerified Boolean
}

// Relations: camelCase, descriptive
model Appointment {
  user User @relation("UserAppointments")
  practitioner Practitioner @relation("PractitionerAppointments")
}

// Enums: PascalCase
enum UserRole {
  USER
  PRACTITIONER
  MERCHANT
  ADMIN
}
```

### 2. Field Types

```prisma
// Use appropriate types
model User {
  id String @id @default(cuid())  // Unique identifiers
  email String @unique             // Unique constraints
  password String                  // Hashed, never plain text
  avatar String?                   // Optional with ?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt    // Auto-updated
}

// Decimal for money
model Invoice {
  amount Decimal @db.Decimal(10, 2)  // Precision for currency
}

// JSON for flexible data
model Settings {
  preferences Json
}
```

### 3. Indexes

```prisma
model Practitioner {
  email String @unique
  city String
  specialty String
  rating Float

  // Single field indexes
  @@index([city])
  @@index([specialty])

  // Composite indexes
  @@index([city, specialty])

  // Unique constraints
  @@unique([email, specialty])
}
```

### 4. Relations

```prisma
// One-to-Many
model User {
  id String @id @default(cuid())
  appointments Appointment[]
}

model Appointment {
  id String @id @default(cuid())
  userId String
  user User @relation(fields: [userId], references: [id])
}

// Many-to-Many (explicit join table)
model User {
  favorites UserFavorite[]
}

model Practitioner {
  favoritedBy UserFavorite[]
}

model UserFavorite {
  userId String
  practitionerId String
  user User @relation(fields: [userId], references: [id])
  practitioner Practitioner @relation(fields: [practitionerId], references: [id])

  @@id([userId, practitionerId])
}

// One-to-One
model User {
  id String @id @default(cuid())
  practitionerProfile Practitioner?
}

model Practitioner {
  id String @id @default(cuid())
  userId String @unique
  user User @relation(fields: [userId], references: [id])
}
```

### 5. Cascading Deletes

```prisma
model User {
  id String @id @default(cuid())
  appointments Appointment[]
}

model Appointment {
  id String @id @default(cuid())
  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  // When user is deleted, their appointments are also deleted
}
```

## Troubleshooting

### Migration Conflicts

**Problem**: Migration conflicts with existing data

```
Developer: "Migration fails due to non-nullable field"

Claude Solution:
1. Create migration in two steps:
   - Step 1: Add field as nullable
   - Step 2: Populate field, then make non-nullable

2. Or provide default value:
```prisma
model User {
  role UserRole @default(USER)
}
```

### Schema Validation Errors

**Problem**: Invalid schema syntax

```
Developer: "Schema validation fails"

Claude Actions:
1. Read schema file
2. Identify syntax errors
3. Suggest corrections
4. Validate corrected schema
```

### Type Mismatches

**Problem**: TypeScript errors after schema changes

```
Developer: "Types don't match after schema update"

Claude Solution:
1. Regenerate Prisma Client: `npx prisma generate`
2. Restart TypeScript server
3. Clear build cache if needed
```

## Advanced Features

### 1. Raw Queries

```typescript
// Generated by Claude when complex SQL is needed
const result = await prisma.$queryRaw`
  SELECT p.*, COUNT(r.id) as review_count
  FROM "Practitioner" p
  LEFT JOIN "Review" r ON r."practitionerId" = p.id
  WHERE p.city = 'Paris'
  GROUP BY p.id
  HAVING COUNT(r.id) > 5
  ORDER BY review_count DESC
`;
```

### 2. Transactions

```typescript
// Generated by Claude for atomic operations
const result = await prisma.$transaction([
  prisma.user.update({
    where: { id: userId },
    data: { credits: { decrement: 100 } }
  }),
  prisma.appointment.create({
    data: {
      userId,
      practitionerId,
      dateTime,
      cost: 100
    }
  })
]);
```

### 3. Middleware

```typescript
// Generated by Claude for logging/auditing
prisma.$use(async (params, next) => {
  const before = Date.now();
  const result = await next(params);
  const after = Date.now();
  console.log(`Query ${params.model}.${params.action} took ${after - before}ms`);
  return result;
});
```

## Resources

- [Prisma MCP Server Docs](https://www.prisma.io/docs/postgres/integrations/mcp-server)
- [Prisma Schema Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference)
- [Prisma Client API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference)
- [Migration Best Practices](https://www.prisma.io/docs/guides/migrate/production-troubleshooting)

## Next Steps

- Review [Integration Guide](./integration-guide.md) for using multiple MCP servers together
- Check [Main README](./README.md) for overview of all MCP servers
- Explore example prompts in `.mcp/servers/database.json`
